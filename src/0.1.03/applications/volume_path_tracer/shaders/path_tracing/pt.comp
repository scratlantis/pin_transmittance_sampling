#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

#include "pt_common.glsl"
#include "../medium/pins_common.glsl"
#include "../template.glsl"

COMPUTE_SHADER_ID_IN
// Constants
SHADER_BLOCK_3_FRAME_VIEW_PARAMS(0)
// Target
layout(binding = 3, FORMAT1) writeonly uniform image2D colorOut;
// Scene data
SHADER_BLOCK_11_USCENE(4)
// General config
struct PushStruct
{
	uint volRes;
	uint pinGridSize;
	uint pinCountPerGridCell;
	uint pinTransmittanceValueCount;
};

layout(push_constant) uniform PUSH_CONSTANTS {PushStruct pc;};
layout(binding = 15) uniform sampler3D volSmp;
layout(binding = 16) uniform VOLUME_INSTANCE { GLSLMediumInstance volInst;};

#ifdef USE_PINS
layout(binding = 17) readonly buffer PIN_GRID {GLSLPinGridEntry pinGrid[];};
layout(binding = 18) readonly buffer PIN_TRANSMITTANCE { float pinTransmittance[];};



#ifndef PIN_MODE
#define PIN_MODE PIN_MODE_FLAG_INDIRECT
#endif
#endif

#ifndef PIN_MODE
#define PIN_MODE 0
#endif

#define PATH_TERMINATED_ZERO 0
#define PATH_TERMINATED_INFINITY 1
#define PATH_SURFACE_SCATTER 2
#define PATH_MEDIUM_SCATTER 3


struct HitData
{
	uint instanceCustomID;
	uint geometryID;
	uint primitiveID;
	vec3 barycentrics;
	mat4x3 objToWorld;
};

float traceGeometry(Ray ray, inout HitData hData)
{
	rayQueryEXT rq;
	rayQueryInitializeEXT(rq, as, gl_RayFlagsOpaqueEXT, 0xFF, ray.origin, ray.tmin, ray.direction, ray.tmax);
	while(rayQueryProceedEXT(rq)){}
	if(rayQueryGetIntersectionTypeEXT(rq, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
	{
		hData.instanceCustomID = rayQueryGetIntersectionInstanceCustomIndexEXT(rq, true);
		hData.geometryID = rayQueryGetIntersectionGeometryIndexEXT(rq, true);
		hData.primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rq, true);
		hData.barycentrics.yz = rayQueryGetIntersectionBarycentricsEXT(rq, true);
		hData.barycentrics.x = 1.0 - hData.barycentrics.y - hData.barycentrics.z;
		hData.objToWorld = rayQueryGetIntersectionObjectToWorldEXT(rq, true);
		return rayQueryGetIntersectionTEXT(rq, true);
	}
	return MAX_FLOAT;
}

struct Range
{
	float rMin;
	float rMax;
};



Range traceMediumConservative(Ray ray)
{
	vec3 localOrigin = (volInst.invMat * vec4(ray.origin, 1.0)).xyz;
	vec3 localDir = (volInst.invMat * vec4(ray.direction, 0.0)).xyz;
	vec3 localEntry, localExit;
	Range range;
	bool intersect = unitCubeIntersection(localOrigin, localDir, localEntry, localExit);
	if(intersect && distance(localEntry, localExit) > distance(localOrigin, localExit)) 
	{
		// Inside Cube
		vec3 worldExitPos = (volInst.mat * vec4(localExit, 1.0)).xyz;
		range.rMin = 0.0;
		range.rMax = distance(ray.origin, worldExitPos);
	}
	else if(intersect)
	{
	    // Intersect Cube
		vec3 worldEntryPos = (volInst.mat * vec4(localEntry, 1.0)).xyz;
		vec3 worldExitPos = (volInst.mat * vec4(localExit, 1.0)).xyz;
		range.rMin = distance(ray.origin, worldEntryPos);
		range.rMax = distance(ray.origin, worldExitPos);
	}
	else
	{
		// Miss Cube
		range.rMin = MAX_FLOAT;
		range.rMax = MAX_FLOAT;
	}
	return range;
}
#ifdef USE_PINS
GLSLPinGridEntry selectPin(vec3 origin, vec3 direction, float maxLenght, inout uint seed)
{
	origin = clamp(vec3(0.0),vec3(0.9999), origin);
	uvec3 gridId = uvec3(origin*float(pc.pinGridSize));
	uint cellIdx = flatten(gridId, uvec3(pc.pinGridSize)) * pc.pinCountPerGridCell;

	float maxDot = 0.0;
	GLSLPinGridEntry maxDotPin;
	for(uint i = 0; i < pc.pinCountPerGridCell; i++)
	{
		GLSLPinGridEntry gridEntry = pinGrid[cellIdx + i];
		float dotVal = abs(dot(getPinDirection(gridEntry.pin), direction));
		if(dotVal > maxDot)
		{
			maxDot = dotVal;
			maxDotPin = gridEntry;
		}
	}
	return maxDotPin;
}

float samplePin(vec3 origin, vec3 destination, GLSLPinGridEntry gridEntry)
{
	vec3 pinOrigin = getPinOrigin(gridEntry.pin);
	vec3 pinDestination = getPinDestination(gridEntry.pin);
	vec3 pinDirection = getPinDirection(gridEntry.pin);
	vec3 direction = normalize(destination - origin);

	vec2 sampleLocation = projectRaySegment(pinOrigin, pinDestination, origin, destination);
	sampleLocation = clamp(sampleLocation, 0.0, 0.9999);
	sampleLocation *= vec2(pc.pinTransmittanceValueCount);
	uvec2 rightSampleIndex = uvec2(sampleLocation);
	vec2 uv = sampleLocation - floor(sampleLocation);
	uint baseIndex = gridEntry.idx * pc.pinTransmittanceValueCount;

	// right
	vec2 rightSampleValue = vec2(pinTransmittance[baseIndex + rightSampleIndex.x], pinTransmittance[baseIndex + rightSampleIndex.y]);

	// left
	vec2 leftSampleValue;
	if(rightSampleIndex.x == 0)
	{
		leftSampleValue.x = 0.0;
	}
	else
	{
		leftSampleValue.x = pinTransmittance[baseIndex + rightSampleIndex.x - 1];
	}
	if(rightSampleIndex.y == 0)
	{
		leftSampleValue.y = 0.0;
	}
	else
	{
		leftSampleValue.y = pinTransmittance[baseIndex + rightSampleIndex.y - 1];
	}

	vec2 sampleValue = mix(leftSampleValue, rightSampleValue, uv);
	float cumulativDensity = abs(sampleValue.x - sampleValue.y);
	cumulativDensity*=distance(pinOrigin, pinDestination);
	cumulativDensity /= min(dot(pinDirection, direction), 0.01);
	float transmittance = exp(-cumulativDensity);

	return transmittance;
}

float pinMarcheMedium(vec3 origin, vec3 direction, float maxLenght, inout uint seed)
{
	float rng = unormNext(seed);
	const float max_steps = sqrt(3.0) * 2.0 / AVERAGE_RAY_MARCHE_STEP_SIZE;
	float t = 0.0;
	float transmittance = 1.0;
	float stepSize = AVERAGE_RAY_MARCHE_STEP_SIZE * unormNext(seed);
	stepSize = min(stepSize, maxLenght);

	GLSLPinGridEntry pinGridEntry = selectPin(origin, direction, maxLenght, seed);

	for(uint i = 0; i < max_steps; i++)
	{
		t += stepSize;
		vec3 pos = origin + direction * (t-stepSize*unormNext(seed));

		// Sample transmittance
		transmittance = samplePin(origin, pos, pinGridEntry);

		// Decide if we should stop
		if(transmittance < rng)
		{
			return t;
		}

		stepSize = min(AVERAGE_RAY_MARCHE_STEP_SIZE, maxLenght - t);
		if( stepSize < EPSILON)
		{
			return MAX_FLOAT;
		}
	}
	return MAX_FLOAT;
}
#endif

// return step size
float rayMarcheMedium(vec3 origin, vec3 direction, float maxLenght, inout uint seed)
{
	float rng = unormNext(seed);
	const float max_steps = sqrt(3.0) * 2.0 / AVERAGE_RAY_MARCHE_STEP_SIZE;
	float t = 0.0;
	float transmittance = 1.0;
	float stepSize = AVERAGE_RAY_MARCHE_STEP_SIZE * unormNext(seed);
	stepSize = min(stepSize, maxLenght);

	for(uint i = 0; i < max_steps; i++)
	{
		t += stepSize;
		vec3 pos = origin + direction * (t-stepSize*unormNext(seed));

		// Sample density
		float density = texture(volSmp, pos).r;
		transmittance *= exp(-density * stepSize);

		// Decide if we should stop
		if(transmittance < rng)
		{
			return t;
		}

		stepSize = min(AVERAGE_RAY_MARCHE_STEP_SIZE, maxLenght - t);
		if( stepSize < EPSILON)
		{
			return MAX_FLOAT;
		}
	}
	return MAX_FLOAT;
}








float traceMedium(Ray ray, Range range, inout uint seed, uint bounce)
{
	vec3 localOrigin = (volInst.invMat * vec4(ray.origin + range.rMin * ray.direction, 1.0)).xyz;
	vec3 localExit = (volInst.invMat * vec4(ray.origin + range.rMax * ray.direction, 1.0)).xyz;
	vec3 localDir = normalize(volInst.invMat * vec4(ray.direction, 0.0)).xyz;
	float localTMax = distance(localOrigin, localExit);

	#if((PIN_MODE & PIN_MODE_FLAG_INDIRECT) != 0)
		float tLocal;
		if(bounce > 0)
		{
			tLocal = pinMarcheMedium(localOrigin, localDir, localTMax, seed);
		}
		else
		{
			tLocal = rayMarcheMedium(localOrigin, localDir, localTMax, seed);
		}
	#else
		float tLocal = rayMarcheMedium(localOrigin, localDir, localTMax, seed);
	#endif

	if(tLocal == MAX_FLOAT)
	{
		return MAX_FLOAT;
	}
	vec3 worldHitPos = (volInst.mat * vec4(localOrigin + tLocal * localDir, 1.0)).xyz;
	return distance(ray.origin, worldHitPos);
}



// Return tangent frame
void evalHit(inout MaterialData matData, inout mat4x3 tangentFrame, HitData hitData)
{
	VKAModelDataOffset modelOffset = modelOffsets[hitData.instanceCustomID];
	uint firstIndex = surfaceIndexOffsets[modelOffset.firstSurface + hitData.geometryID] + hitData.primitiveID * 3;
	GLSLVertex v0 = vertices[indices[firstIndex    ] + modelOffset.firstVertex];
	GLSLVertex v1 = vertices[indices[firstIndex + 1] + modelOffset.firstVertex];
	GLSLVertex v2 = vertices[indices[firstIndex + 2] + modelOffset.firstVertex];
	vec2 uv = mat3x2(v0.uv, v1.uv, v2.uv) * hitData.barycentrics;

	// Material
	GLSLMaterial mat = materials[modelOffset.firstSurface + hitData.geometryID];
	// Add texture reads later
	matData.albedo = mat.albedo;
	matData.specular = mat.specular;
	matData.emission = 20.0 * mat.emission;
	matData.roughness = mat.roughness;
	matData.f0 = mat.f0;

	// Compute tangent frame
	vec3 localPos = mat3(v0.pos, v1.pos, v2.pos) * hitData.barycentrics;
	vec3 localGeometricNormal = normalize(mat3(v0.normal, v1.normal, v2.normal) * hitData.barycentrics);
	vec3 worldPos = hitData.objToWorld * vec4(localPos, 1.0);
	vec3 worldNormal = normalize(hitData.objToWorld * vec4(localGeometricNormal, 0.0));
	tangentFrame = tangentFrameFromPosNormal(worldPos,worldNormal);
}


float rayMarcheMediumTransmittance(vec3 origin, vec3 direction, float maxLenght, inout uint seed)
{
	const float max_steps = sqrt(3.0) * 2.0 / AVERAGE_RAY_MARCHE_STEP_SIZE;
	float t = 0.0;
	float transmittance = 1.0;
	float stepSize = AVERAGE_RAY_MARCHE_STEP_SIZE * unormNext(seed);
	stepSize = min(stepSize, maxLenght);
	for(uint i = 0; i < max_steps; i++)
	{
		t += stepSize;
		vec3 pos = origin + direction * (t-stepSize*unormNext(seed));

		// Sample density
		float density = texture(volSmp, pos).r;
		transmittance *= exp(-density * stepSize);

		stepSize = min(AVERAGE_RAY_MARCHE_STEP_SIZE, maxLenght - t);
		if( stepSize < EPSILON)
		{
			return transmittance;
		}
	}
	return transmittance;
}

float traceMediumTransmittance(Ray ray, Range range, inout uint seed, uint bounce)
{
	vec3 localOrigin = (volInst.invMat * vec4(ray.origin + range.rMin * ray.direction, 1.0)).xyz;
	vec3 localExit = (volInst.invMat * vec4(ray.origin + range.rMax * ray.direction, 1.0)).xyz;
	vec3 localDir = normalize(volInst.invMat * vec4(ray.direction, 0.0)).xyz;
	float localTMax = distance(localOrigin, localExit);

	float transmittance = rayMarcheMediumTransmittance(localOrigin, localDir, localTMax, seed);
	return transmittance;
}




VKAAreaLight selectAreaLight(mat4x3 tangentFrame, inout uint seed, out float localPdf)
{
	VKAAreaLight areaLight;
	uint lightIdx = uint(AREA_LIGHT_COUNT * unormNext(seed));
	localPdf = 1.0; // uniform pdf
	areaLight = areaLights[lightIdx];
	mat4 transform = modelTransforms[areaLight.modelIndex];
	areaLight.v0 = vec3(transform*vec4(areaLight.v0, 1.0));
	areaLight.v1 = vec3(transform*vec4(areaLight.v1, 1.0));
	areaLight.v2 = vec3(transform*vec4(areaLight.v2, 1.0));
	areaLight.normal = vec3(transform*vec4(areaLight.normal, 0.0));
	return areaLights[lightIdx];
}

Ray genDirectIllumRay(mat4x3 tangentFrame, inout uint seed, out float localPdf, out vec3 localWeight)
{
	float selectionPDF, samplePDF;
	VKAAreaLight areaLight = selectAreaLight(tangentFrame, seed, selectionPDF);
	vec3 samplePos  = sampleAreaLight(tangentFrame, areaLight, seed, samplePDF);
	localPdf = selectionPDF * samplePDF;
	localWeight = vec3(areaLight.intensity);
	Ray ray;
	ray.origin = tangentFrame[3];
	ray.direction = normalize(samplePos-ray.origin);
	ray.tmin = TMIN;
	ray.tmax = TMAX;
	return ray;
}

float traceGeometryTransmittance(Ray ray)
{
	rayQueryEXT rq;
	float transmittance;
	rayQueryInitializeEXT(rq, as, gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT , 0xFF, ray.origin, ray.tmin, ray.direction, ray.tmax);
	while(rayQueryProceedEXT(rq)){}
	if(rayQueryGetIntersectionTypeEXT(rq, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
	{
		transmittance = 0.0;
	}
	else
	{
		transmittance = 1.0;
	}
	return transmittance;
}


float traceTransmittance(Ray ray, inout uint seed, uint bounce)
{
	float geomTransmittance = traceGeometryTransmittance(ray);

	if(geomTransmittance == 0.0)
	{
		return geomTransmittance;
	}

	Range rMedium = traceMediumConservative(ray);
	if(rMedium.rMin == MAX_FLOAT)
	{
		return geomTransmittance;
	}


	float mediumTransmittance = traceMediumTransmittance(ray, rMedium, seed, bounce);
	return geomTransmittance * mediumTransmittance;
}

vec3 sampleDirectIllum(mat4x3 tangentFrame, inout vec3 direction, inout uint seed, uint bounce)
{
	float localPdf;
	vec3 localWeight;
	Ray ray = genDirectIllumRay(tangentFrame, seed, localPdf, localWeight);
	direction = ray.direction;
	if(localPdf < EPSILON)
	{
		return vec3(0.0);
	}

	float transmittance = traceTransmittance(ray, seed, bounce);
	vec3 Li = transmittance * (localWeight / localPdf);
	return Li;
}


uint nextBounce(
	inout Ray ray, inout uint seed, inout float pdf, inout vec3 weight, // Full Ray payload
	out HitData hitData, out MaterialData matData, out mat4x3 tangentFrame, // Hit data
	uint bounce)
{
	float tGeom = traceGeometry(ray, hitData);
	float tMedium = MAX_FLOAT;
	Range rMedium = traceMediumConservative(ray);
	rMedium.rMax = min(rMedium.rMax, tGeom);
	if(tGeom < rMedium.rMin)
	{
		evalHit(matData, tangentFrame, hitData);
		ray = reflectLampertDiffuse(matData, tangentFrame, seed, pdf, weight);
		return PATH_SURFACE_SCATTER;
	}
	else if( rMedium.rMin == MAX_FLOAT )
	{
		return PATH_TERMINATED_INFINITY;
	}
	else
	{
		tMedium = traceMedium(ray, rMedium, seed, bounce);
		if(tGeom < tMedium)
		{
			evalHit(matData, tangentFrame, hitData);
			ray = reflectLampertDiffuse(matData, tangentFrame, seed, pdf, weight);
			return PATH_SURFACE_SCATTER;
		}
		else if( tMedium == MAX_FLOAT )
		{
			return PATH_TERMINATED_INFINITY;
		}
		else
		{
			ray = scatterUniform(volInst.albedo, ray.origin + tMedium * ray.direction, seed, pdf, weight);
			return PATH_MEDIUM_SCATTER;
		}
	}
	return PATH_TERMINATED_ZERO;
}

void main()
{
	COMPUTE_SHADER_CHECK_ID_FRAME
	uint seed = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * frame.width + frame.width*frame.height*frame.idx;
	vec3 totalIllumination = vec3(0.0);
	uint N = 0; // Number of light paths
	
	for(uint j = 0; j < SAMPLE_COUNT; j++)
	{
		float pdf = 1.0;
		vec3 weight = vec3(1.0);
		Ray ray = genPrimaryRay(frame, view, gl_GlobalInvocationID.xy, seed);

		for(uint i = 0; i < MAX_BOUNCES; i++)
		{
			vec3 coef = weight / pdf;

			HitData hitData;
			MaterialData matData;
			mat4x3 tangentFrame;

			uint pathState = nextBounce(ray, seed, pdf, weight, hitData, matData, tangentFrame, i);

			if(pathState == PATH_TERMINATED_ZERO)
			{
				break;
			}
			else if(pathState == PATH_TERMINATED_INFINITY)
			{
				totalIllumination += vec3(0.4) * coef; // Replace with envmap
				N++;
				break;
			}
			else if(pathState == PATH_SURFACE_SCATTER) 
			{
				vec3 Le = vec3(0.0); // Emission from light sources collected via NEE
				vec3 wi;
				vec3 Li = sampleDirectIllum(tangentFrame, wi, seed, i);
				vec3 brdf = lampertBRDF(matData.albedo);
				float cosTheta = max(0.0, dot(tangentFrame[2], wi));
				vec3 Lo = Le + brdf * Li * cosTheta;

				totalIllumination += coef * Lo;
				N++;
			}
			else if(pathState == PATH_MEDIUM_SCATTER)
			{
				vec3 Le = vec3(0.0); // No emission from medium
				vec3 wi;
				vec3 Li = sampleDirectIllum(tangentFrame, wi, seed, i);
				vec3 volumeBSDF = uniformScatterBSDF(volInst.albedo);
				vec3 Lo = Le + volumeBSDF * Li;

				totalIllumination += coef * Lo;
				N++;
			}
		}
	}
	if(N > 1)
	{
		totalIllumination /= float(N);
	}
	imageStore(colorOut, gID.xy, vec4(totalIllumination, 1.0));
}





/*
void main()
{
	COMPUTE_SHADER_CHECK_ID_FRAME
	uint seed = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * frame.width + frame.width*frame.height*frame.idx;
	HitData hitData;
	MaterialData matData;
	mat4x3 tangentFrame;
	vec3 totalIllumination = vec3(0.0);

	
	for(uint j = 0; j < SAMPLE_COUNT; j++)
	{
		float pdf = 1.0;
		vec3 weight = vec3(1.0);
		Ray ray = genPrimaryRay(frame, view, gl_GlobalInvocationID.xy, seed);

		for(uint i = 0; i < MAX_BOUNCES; i++)
		{
			float tGeom = traceGeometry(ray, hitData);
			float tMedium = MAX_FLOAT;
			Range rMedium = traceMediumConservative(ray);
			rMedium.rMax = min(rMedium.rMax, tGeom);
			if(tGeom < rMedium.rMin)
			{
				evalHit(matData, tangentFrame, hitData);
				totalIllumination += matData.emission * weight / pdf;
				ray = reflectLampertDiffuse(matData, tangentFrame, seed, pdf, weight);
			}
			else if( rMedium.rMin == MAX_FLOAT )
			{
				totalIllumination += vec3(0.4) * weight / pdf;
				break;
			}
			else
			{
				tMedium = traceMedium(ray, rMedium, seed, i);
				if(tGeom < tMedium)
				{
					evalHit(matData, tangentFrame, hitData);
					totalIllumination += matData.emission * weight / pdf;
					ray = reflectLampertDiffuse(matData, tangentFrame, seed, pdf, weight);
				}
				else if( tMedium == MAX_FLOAT )
				{
					totalIllumination += vec3(0.4) * weight / pdf;
					break;
				}
				else
				{
					ray = scatterUniform(volInst.albedo, ray.origin + tMedium * ray.direction, seed, pdf, weight);
				}
			}
		}
	}
	totalIllumination /= float(SAMPLE_COUNT);
	imageStore(colorOut, gID.xy, vec4(totalIllumination, 1.0));
}
*/