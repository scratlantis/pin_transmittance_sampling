#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

#include "pt_common.glsl"
#include "../template.glsl"

COMPUTE_SHADER_ID_IN
// Constants
SHADER_BLOCK_3_FRAME_VIEW_PARAMS(0)
// Target
layout(binding = 3, FORMAT1) writeonly uniform image2D colorOut;
// Scene data
SHADER_BLOCK_10_USCENE(4)

struct PushStruct
{
	uint volRes;
};

layout(push_constant) uniform PUSH_CONSTANTS {PushStruct pc;};
layout(binding = 14) uniform sampler3D volSmp;
layout(binding = 15) uniform VOLUME_INSTANCE { GLSLMediumInstance volInst;};


struct HitData
{
	uint instanceCustomID;
	uint geometryID;
	uint primitiveID;
	vec3 barycentrics;
	mat4x3 objToWorld;
};

float trace(Ray ray, inout HitData hData)
{
	rayQueryEXT rq;
	rayQueryInitializeEXT(rq, as, gl_RayFlagsOpaqueEXT, 0xFF, ray.origin, ray.tmin, ray.direction, ray.tmax);
	while(rayQueryProceedEXT(rq)){}
	if(rayQueryGetIntersectionTypeEXT(rq, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
	{
		hData.instanceCustomID = rayQueryGetIntersectionInstanceCustomIndexEXT(rq, true);
		hData.geometryID = rayQueryGetIntersectionGeometryIndexEXT(rq, true);
		hData.primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rq, true);
		hData.barycentrics.yz = rayQueryGetIntersectionBarycentricsEXT(rq, true);
		hData.barycentrics.x = 1.0 - hData.barycentrics.y - hData.barycentrics.z;
		hData.objToWorld = rayQueryGetIntersectionObjectToWorldEXT(rq, true);
		return rayQueryGetIntersectionTEXT(rq, true);
	}
	return MAX_FLOAT;
}


float traceMediumConservative(Ray ray)
{
	vec3 localOrigin = (volInst.invMat * vec4(ray.origin, 1.0)).xyz;
	vec3 localDir = (volInst.invMat * vec4(ray.direction, 0.0)).xyz;
	vec3 localEntry, localExit;

	bool intersect = unitCubeIntersection(localOrigin, localDir, localEntry, localExit);
	if(intersect && distance(localEntry, localExit) > distance(localOrigin, localExit)) 
	{
		return 0.0; // Inside Cube
	}
	else if(intersect)
	{
	    // Intersect Cube
		vec3 worldEntryPos = (volInst.mat * vec4(localEntry, 1.0)).xyz;
		return distance(ray.origin, worldEntryPos);
	}
	return MAX_FLOAT; // Miss Cube
}



// return step size
float rayMarcheMedium(vec3 origin, vec3 direction, inout uint seed)
{
	float rng = unormNext(seed);
	const float max_steps = sqrt(3.0) * 2.0 / AVERAGE_RAY_MARCHE_STEP_SIZE;
	float t = 0.0;
	float transmittance = 1.0;
	for(uint i = 0; i < max_steps; i++)
	{
		float stepSize = AVERAGE_RAY_MARCHE_STEP_SIZE + (0.5 - rng) * AVERAGE_RAY_MARCHE_STEP_SIZE;
		t += stepSize;
		vec3 pos = origin + direction * t;

		// Clamp to unit cube
		vec3 clampedPos = clamp(pos, 0.0, 1.0);
		float deltaClamped = distance(clampedPos,pos);
		t -= deltaClamped;
		pos = origin + direction * t;

		// Sample density
		float density = texture(volSmp, pos).r;
		transmittance *= exp(-density * stepSize);

		// Decide if we should stop
		if(transmittance < rng)
		{
			return t;
		}
		if(deltaClamped > 0)
		{
			return MAX_FLOAT; // Hit the boundary without scattering
		}
	}
	return MAX_FLOAT;
}

float traceMedium(Ray ray, float tEntry, inout uint seed)
{
	vec3 localOrigin = (volInst.invMat * vec4(ray.origin + tEntry * ray.direction, 1.0)).xyz;
	vec3 localDir = (volInst.invMat * vec4(ray.direction, 0.0)).xyz;
	float tLocal = rayMarcheMedium(localOrigin, localDir, seed);
	if(tLocal == MAX_FLOAT)
	{
		return MAX_FLOAT;
	}
	vec3 worldHitPos = (volInst.mat * vec4(localOrigin + tLocal * localDir, 1.0)).xyz;
	return distance(ray.origin, worldHitPos);
}



// Return tangent frame
void evalHit(inout MaterialData matData, inout mat4x3 tangentFrame, HitData hitData)
{
	VKAModelDataOffset modelOffset = modelOffsets[hitData.instanceCustomID];
	uint firstIndex = surfaceIndexOffsets[modelOffset.firstSurface + hitData.geometryID] + hitData.primitiveID * 3;
	GLSLVertex v0 = vertices[indices[firstIndex    ] + modelOffset.firstVertex];
	GLSLVertex v1 = vertices[indices[firstIndex + 1] + modelOffset.firstVertex];
	GLSLVertex v2 = vertices[indices[firstIndex + 2] + modelOffset.firstVertex];
	vec2 uv = mat3x2(v0.uv, v1.uv, v2.uv) * hitData.barycentrics;

	// Material
	GLSLMaterial mat = materials[modelOffset.firstSurface + hitData.geometryID];
	// Add texture reads later
	matData.albedo = mat.albedo;
	matData.specular = mat.specular;
	matData.emission = mat.emission;
	matData.roughness = mat.roughness;
	matData.f0 = mat.f0;

	// Compute tangent frame
	vec3 localPos = mat3(v0.pos, v1.pos, v2.pos) * hitData.barycentrics;
	vec3 localGeometricNormal = normalize(mat3(v0.normal, v1.normal, v2.normal) * hitData.barycentrics);
	vec3 worldPos = hitData.objToWorld * vec4(localPos, 1.0);
	vec3 worldNormal = hitData.objToWorld * vec4(localGeometricNormal, 0.0);
	tangentFrame = tangentFrameFromPosNormal(worldPos,worldNormal);
}


void main()
{
	COMPUTE_SHADER_CHECK_ID_FRAME
	uint seed = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * frame.width + frame.width*frame.height*frame.idx;
	HitData hitData;
	MaterialData matData;
	mat4x3 tangentFrame;
	vec3 totalIllumination = vec3(0.0);


	for(uint j = 0; j < SAMPLE_COUNT; j++)
	{
		float pdf = 1.0;
		vec3 weight = vec3(1.0);
		Ray ray = genPrimaryRay(frame, view, gl_GlobalInvocationID.xy, seed);

		for(uint i = 0; i < MAX_BOUNCES; i++)
		{
			float tGeom = trace(ray, hitData);
			float tMedium = traceMediumConservative(ray);
			if(tGeom < tMedium)
			{
				evalHit(matData, tangentFrame, hitData);
				totalIllumination += matData.emission * weight / pdf;
				ray = reflectLampertDiffuse(matData, tangentFrame, seed, pdf, weight);
			}
			else if( tMedium == MAX_FLOAT )
			{
				totalIllumination += vec3(0.4) * weight / pdf;
				break;
			}
			else
			{
				tMedium = traceMedium(ray, tMedium, seed);
				if(tGeom < tMedium)
				{
					evalHit(matData, tangentFrame, hitData);
					totalIllumination += 10.0*matData.emission * weight / pdf;
					ray = reflectLampertDiffuse(matData, tangentFrame, seed, pdf, weight);
				}
				else if( tMedium == MAX_FLOAT )
				{
					totalIllumination += vec3(0.4) * weight / pdf;
					break;
				}
				else
				{
					ray = scatterUniform(volInst.albedo, ray.origin + tMedium * ray.direction, seed, pdf, weight);
				}
			}


		}
	}
	totalIllumination /= float(SAMPLE_COUNT);
	imageStore(colorOut, gID.xy, vec4(totalIllumination, 1.0));
}